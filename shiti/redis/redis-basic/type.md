> 专注于PHP、MySQL、Linux和前端开发，感兴趣的感谢点个关注哟！！！文章整理在[GitHub](https://github.com/7small7),[Gitee](https://gitee.com/bruce_qiq)主要包含的技术有PHP、Redis、MySQL、JavaScript、HTML&CSS、Linux、Java、Golang、Linux和工具资源等相关理论知识、面试题和实战内容。

@author:[7small7](https://github.com/7small7)。

@source:[公众号-菜鸟成长学习笔记](/site/)。

@project:[微信小程序 程序员面试题大全](/site/)。

## 你是怎么用Redis做异步队列的？

1. 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

2. 如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。

3. 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

4. 如果对方追问pub/sub有什么缺点？在消费者下线的情况下，**生产的消息会丢失**，可以使用Redis6增加的**stream数据类型**，也可以使用专业的**消息队列如rabbitmq等**。

5. 如果对方追问redis如何实现延时队列？**使用sortedset，拿时间戳作为score**，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

## Redis使用场景

1.数据缓存(用户信息、商品数量、文章阅读数量)

2.消息推送(站点的订阅)

3.队列(削峰、解耦、异步)

4.排行榜(积分排行)

5.社交网络(共同好友、互踩、下拉刷新)

6.计数器(商品库存，站点在线人数、文章阅读、点赞)

7.基数计算

8.GEO计算

## Redis功能特点

1. 持久化
2. 丰富的数据类型(string、list、hash、set、zset、发布订阅等)
3. 高可用方案(哨兵、集群、主从)
4. 事务
5. 丰富的客户端
6. 提供事务
7. 消息发布订阅
8. Geo
9. HyperLogLog
10. 事务

## 说说Redis各种数据类型的底层数据结构？

1. string底层数据结构为简单字符串。
  
2. list底层数据结构为ziplist和linkedlist。

3. hash底层数据结构为ziplist和hashtable。

4. set底层数据结构为intset和hashtable。

5. sorted set底层数据结构为ziplist和skiplist。

## 如何使用Redis实现队列功能？

1. 可以使用list实现普通队列，lpush添加到嘟列，lpop从队列中读取数据。

2. 可以使用zset定期轮询数据，实现延迟队列。

3. 可以使用发布订阅实现多个消费者队列。

4. 可以使用stream实现队列。(推荐使用该方式实现)。

## 能谈谈使用Redis Stream做队列，比list，zset和发布订阅有什么区别吗？

1. list可以使用lpush向队列中添加数据，lpop可以向队列中读取数据。list作为消息队列无法实现一个消息多个消费者。如果出现消息处理失败，需要手动回滚消息。

2. zset在添加数据时，需要添加一个分值，可以根据该分值对数据进行排序，实现延迟消息队列的功能。消息是否消费需要额外的处理。

3. 发布订阅可以实现多个消费者功能，但是发布订阅无法实现数据持久化，容易导致数据丢失。并且开启一个订阅者无法获取到之前的数据。

4. stream借鉴了常用的MQ服务，添加一个消息就会产生一个消息ID，每一个消息ID下可以对应多个消费组，每一个消费组下可以对应多个消费者。可以实现多个消费者功能，同时支持ack机制，减少数据的丢失情况。也是支持数据值持久化和主从复制功能。

## 设计一个网站每日、每月和每天的PV、UV你该怎么设计？

实现这样的功能，如果只是统计一个汇总数据，推荐使用HyperLogLog数据类型。Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

## 如何使用Redis实现附近距离检索功能？

实现距离检索，可以使用Redis中的GEO数据类型。GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。但是GEO适合精度不是很高的场景。由于GEO是在内存中进行计算，具备计算速度快的特点。
## 结合Redis中的list，发布订阅，说说用他们实现的队列存在哪些弊端？

1. list可以使用lpush向队列中添加数据，lpop可以向队列中读取数据。list作为消息队列无法实现一个消息多个消费者。如果出现消息处理失败，需要手动回滚消息。

2. 发布订阅可以实现多个消费者功能，但是发布订阅无法实现数据持久化，容易导致数据丢失。并且开启一个订阅者无法获取到之前的数据。

## 如何使用Redis实现一个分布式锁功能？

使用Redis实现分布式锁，可以使用`set key value` + `expire ttl`实现，但是这两个命令分开执行不是一个原子操作，因此推荐使用`set key vale nx ttl`，该命令属于原子操作。

## 使用Redis解决秒杀超卖，该选择什么数据类型？为什么选择该数据类型？

1. 在秒杀场景下，超卖是一个非常严重的问题。常规的逻辑是先查询库存在减少库存。但在秒杀场景中，无法保证减少库存的过程中有其他的请求读取了未减少的库存数据。

2. 由于Redis是单线程的执行，同一时刻只有一个线程进行操作。因此可以使用Redis来实现秒杀减少库存。

3. 在Redis的数据类型中，可以使用lpush，decr命令实现秒杀减少库存。该命令属于原子操作。

## 如何使用Redis实现系统用户签到功能？

1. 使用Redis实现用户签到可以使用bitmap实现。bitmap底层数据存储的是1否者0，占用内存小。

2. Redis提供的数据类型BitMap（位图），每个bit位对应0和1两个状态。虽然内部还是采用String类型存储，但Redis提供了一些指令用于直接操作BitMap，可以把它看作一个bit数组，数组的下标就是偏移量。

3. 它的优点是内存开销小，效率高且操作简单，很适合用于签到这类场景。

4. 缺点在于位计算和位表示数值的局限。如果要用位来做业务数据记录，就不要在意value的值。

## 使用Redis实现延迟队列，该如何实现？

1. 使用Redis实现延迟队列，可以使用zset数据类型。

2. zset在添加数据时，需要添加一个分值，将时间作为分值，根据该分值对数据进行排序。

3. 单独开启线程，根据分值大小定期实行数据。

## 如何使用Redis实现一个积分排行功能？

1. 使用Redis实现积分排行，可以使用zset数据类型。

2. zset在添加数据时，需要添加一个分值，将积分作为分值，值作为用户ID，根据该分值对数据进行排序。

## 一个字符串类型的值能存储最大容量是多少？

一个字符串最大可存储512M。

## Redis事务都有哪些命令?分别有什么作用?

mutil: 开启事务；exec: 提交事务；discard: 回滚事务。watch: 监听key； unwatch: 取消监听key。

## Redis中的事务是否符合事务的原子性?

严格来说，Redis中的事务并非满足事务的原子性操作。如下两种示例：
1. 在事务中执行一条错误的语法命令，整个事务都将不会被执行。

```redis
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set user:name zhangsan
QUEUED
127.0.0.1:6379> set user:age 1
QUEUED
127.0.0.1:6379> set user:sex max
QUEUED
# 执行一条命令错误的操作
127.0.0.1:6379> set a
(error) ERR wrong number of arguments for 'set' command
# 提交事务
127.0.0.1:6379> exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> keys *
1) "user:id:1"
2) "name"
3) "age"
```
2. 在事务中执行了一条语法不当的的操作，最终提交事务后。事务中的正确命令依旧被执行了。

```redis
127.0.0.1:6379> get name
"zhangsan"
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set mu:id 1
QUEUED
# 执行一个语法不当的操作
127.0.0.1:6379> incr name
QUEUED
127.0.0.1:6379> set mu:age 2
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
```
## Redis如何解决事务之间的冲突?

1. 使用watch监听key变化，当key发生变化，事务中的所有操作都会被取消。
2. 使用乐观锁，通过版本号实现。
3. 使用悲观锁，每次开启事务时，都添加一个锁，事务执行结束之后释放锁。

### 悲观锁

悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每 次在拿数据的时候都会上锁，这样别人拿到这个数据就会block直到它拿到锁。传统的关系型数据库里面 就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。

### 乐观锁

乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去那数据的时候都认为别人不会修改，所以 不会上锁，但是在修改的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机 制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。redis就是使用这种check-and-set机制实现 事务的。

### watch监听

在执行multi之前，先执行watch key1 [key2 ...]，可以监视一个或者多个key，若在事务的exec命令之前 这些key对应的值被其他命令所改动了，那么事务中所有命令都将被打断，即事务所有操作将被取消执行。

## Redis事务的三大特性

1. 事务中的所有命令都会序列化、按顺序地执行，事务在执行过程中，不会被其他客户端发送来的命令请求所打断。
2. 队列中的命令没有提交(exec)之前，都不会实际被执行，因为事务提交前任何指令都不会被实际执行。
3. 事务中如果有一条命令执行失败，后续的命令仍然会被执行，没有回滚。如果在组队阶段，有1个失败了，后面都不会成功;如果在组队阶段成功了，在执行阶段有那个命令失败 就这条失败，其他的命令则正常执行，不保证都成功或都失败。