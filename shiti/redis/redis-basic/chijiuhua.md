> 专注于PHP、MySQL、Linux和前端开发，感兴趣的感谢点个关注哟！！！文章整理在[GitHub](https://github.com/7small7),[Gitee](https://gitee.com/bruce_qiq)主要包含的技术有PHP、Redis、MySQL、JavaScript、HTML&CSS、Linux、Java、Golang、Linux和工具资源等相关理论知识、面试题和实战内容。

@author:[7small7](https://github.com/7small7)。

@source:[公众号-菜鸟成长学习笔记](/site/)。

@project:[微信小程序 程序员面试题大全](/site/)。

## Redis持久化都有哪些方式？

1. 快照全量备份的方式(RDB)，使用bgsave或者save命令。bgsave是通过fork一个子进程，异步持久化；save使用同步阻塞的模式进行持久化。
2. 增量日志快照的方式(AOF)，将Redis写命令写入到缓冲区，然后在将缓冲区的命令写入到磁盘中。

## 使用AOF方式做持久化，会遇到什么问题？如何解决？

1. AOF记录的是Redis的写操作命令，当命令数量多时，就会导致文件过大。同时有些缓存数据本身应该是过期了，但对应的写命令还是被保留在文件中。这就出现AOF文件过大的问题。
2. 针对这种情况，Redis采用了重写机制，定期fork一个子进程对AOF文件进行重写，用来减少文件体积并剔除一些过期的命令。
3. AOF重写可以通过自动方式和手动的方式触发，手动可以使用`bgrewriteaof`和自动通过配置文件体积大小时触发。

## 什么是写时复制技术？

1. Redis使用AOF做持久化时，会做重写操作，此时用到了写时复制技术。
2. 在触发重写时，主进程会fork一个子进程，该子进程来负责做重写。在fork之后，子进程和主进程会共享物理内存地址，当有新的操作发生时，会单独复制一块内存空间用作重写操作。

## AOF持久化会保证数据的不丢失吗？

1. 采用AOF持久化，首先写的命令是放在缓冲区中，通过同步策略持久化到磁盘中。可以通过`appendfsync`配置进行操作。具体可配置的值有：

```
always:命令写入到 aof_buf 缓冲区中之后立即调用系统的fsync 操作同步到 aof 文件中，fsync 完成后线程返回。
everysec:命令写入到 aof_buf 缓冲区后每隔一秒调用系统的write 操作，write 完成后线程返回。
no:命令写入 aof_bug 缓冲区后调用系统 write 操作，不对 aof 文件做 fsync 同步，同步硬盘操作由系统操作完成，时间一般最长为 30s。
```

2. fork出来的子进程在做文件重写后，父进程此时会将就的重写文件替换掉。在这个过程中，父进程是一个阻塞的过程，不接受客户端的写命令。这个过程中容易导致数据的丢失。

## RDB和AOF做持久化有什么区别？

### RDB优缺点

1. 优势: 文件实现的数据快照，全量备份，便于数据的传输。比如我们需要把 A 服务器上的备份文件传输到 B 服务器上面，直接将 rdb 文件拷贝即可。文件采用压缩的二进制文件，当重启服务时加载数据文件，比 aof 方式更快(aof是重新去执行一次命令)。
2. 劣势: rbd 采用加密的二进制格式存储文件，由于 Redis 各个版本之间的兼容性问题也导致 rdb 由版本兼容问题导致无法再其他的 Redis 版本中使用。实时性差，并不是完全的实时同步，容易造成数据的不完整性。因为 rdb 并不是实时备份，当某个时间段 Redis 服务出现异常，内存数据丢失，这段时间的数据是无法恢复的，因此易导致数据的丢失。可读性差，由于文件内容采用二进制加密处理，我们无法直接读取，不能修改文件内容。(一般情况我们是不会去查看持久化文件的内容或者去修改持久化的内容)。

### AOF优缺点

1. 优点: 多种文件写入(fsync)策略. 数据实时保存，数据完整性强.即使丢失某些数据，制定好策略最多也是一秒内的数据丢失. 可读性强，由于使用的是文本协议格式来存储的数据,可有直接查看操作的命令，同时也可以手动改写命令。
2. 缺点: 文件体积过大，加载速度比 rbd 慢.由于 aof 记录的是 redis 操作的日志,一些无效的，可简化的操作也会被记录下来,造成 aof 文件过大.但该方式可以通过文件重写策略进行优化.