> 专注于PHP、MySQL、Linux和前端开发，感兴趣的感谢点个关注哟！！！文章整理在[GitHub](https://github.com/7small7),[Gitee](https://gitee.com/bruce_qiq)主要包含的技术有PHP、Redis、MySQL、JavaScript、HTML&CSS、Linux、Java、Golang、Linux和工具资源等相关理论知识、面试题和实战内容。

@author:7small。
@source:公众号-菜鸟成长学习笔记。

## 文章简介

本文将大致介绍索引的类型、InnoDB的索引分类、如何创建索引、使用索引的注意事项等几个方面记录索引。由于侧重点的不同，本文不会全面介绍索引的知识点，例如二叉树、平衡二叉树、B Tree和B + Tree等，后面会单独针对这几种数据结构，进行深度的分享。

## 问题引入

详细很多程序员在面试的时候，都会被问到这样一个问题“MySQL中的索引都有哪些”？或许你很自信的啪啪啪答了一大堆，什么唯一索引、普通索引、主键索引、联合索引等等索引名称，你还以为自己答得非常完美。此时，你看面试官脸上带着一脸嫌弃的样子，你心里瞬间跌入了万丈深渊似的。

不是因为你没有答对，而是因为你回答的方式不对。该文将梳理如何回答该问题。

## 索引定义

什么是索引，想必大家都很熟悉了。使用的字典目录这个案例也是非常之多了。这里个人罗列一下自己对为什么使用索引多一个定义吧(不一定准确，属于个人理解)。

索引是利用数据结构的特点，实现一种为了快速检索数据的存储方式。

## 索引分类
1.B+树索引：是一种由B树和索引访问顺序演变而来的索引，也就是我们常说的一种索引类型。
2.hash索引：是一种等值检索的索引，在innodb中是自适应的，无法人为的去设置，而是通过MySQL内部自动根据情况来设置。
3.空间索引：为了存储地理空间数据的一类索引。
4.全文索引：myisam存储引擎为了检索全文的一种索引类型。

## 数据结构
### 概述
InnoDB索引底层的数据结构采用的是B+树。对该数据结构的了解是有一定难度的。要了解该数据结构就需要对下面的几种数据结构有所认识(因为B+树就是这几种数据结构演变过来的)，这样就更加容易理解B+树。二叉树、平衡二叉树、B树和索引访问顺序。
### 二叉树
特点：每一个节点只会存在两个子节点，节点左侧的值一定是小于根节点的值，节点右侧的值一定是大于根节点的值。
优点：插入数据非常简单，只需要根据每一个节点的值进行大小比较，就可以确定新插入的值放在什么位置。
缺点：当数据量大的时候，树的高度大(节点多)，检索数据同样会很慢，导致效率不高。
### 平衡二叉树
定义：平衡二叉树是由于二叉树的缺点，进行优化、演变而来的数据结构。
特点：平衡二叉树是由二叉树演变而来的一种数据结构，同样也遵循二叉树的特点；二叉树对于树的节点高度，要求相差不能大于1，如果大于1则会通过左右旋进行调整，保证树的节点高度差。
优点：当树的节点高度差，不满足其定义的要求时，树的内部会自动进行左右旋，来保持树的高度差；避免了二叉树的缺点，查询效率高。
缺点：由于需要保证树节点的高度差，则数据结构内部做更新、删除和插入操作时，需要对树的内部结构进行调整，频繁的进行树的左右旋转，也会导致执行效率低下。
### B Tree
[择超自与维基百科](https://zh.wikipedia.org/wiki/B%E6%A0%91)B树（英语：B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。
总结下来，就是在平衡二叉树上面的一种延伸。相对平衡二叉树内部的左旋和右旋更加高效，同时一个节点上可以存在多个子节点。
优点：对于数据结构的更新、插入以及删除相对平衡二叉树更加高效；一个节点上可以存在2个以上的子节点，树的高度就可以降低，因此查询的效率也高很多。
### 索引访问顺序
索引访问顺序的算法是采用ISAM，这种算法也是MyISAM存储引擎采用的一种算法结构。最初是IBM公司发展起来的一个文件系统，可以连续地（按照他们进入的顺序）或者任意地（根据索引）记录任何访问。每个索引定义了一次不同排列的记录。
有点：数据的访问是有序的，这样可以更加快速的找到需要的数据。
### B+Tree
B+Tree是InnoDB中默认的一种索引数据结构，其结合了B Tree和索引访问顺序的两种数据结构实现的。

## 存储引擎

本文的话题是索引，为什么会提出存储引擎这个东西呢？因为不同的存储引擎支持的索引也不同。下面罗列出不同的存储引擎之间的区别：

| 引擎名称 | 支持索引类型 | 
| --- | --- | --- | --- | --- |
| InnoDB | InnoDB支持Hash/B-tree索引类型 |
| MyISAM | MyISAM支持B-tree/FullText/R-tree索引类型 |

> hash索引是不需要我们手动设置的，InnoDB存储引擎的表会自动根据使用情况，调整为hash索引。其他的索引类型，使用的少，暂时也没过多的了解，后期针对该文更新时弥补上。

## 索引分类

索引从数据结构上主要分为下面四种索引类型。其中B+Tree索引使用情况也是最多的。后面文章重点也是总结该索引类型。
1. B+Tree 类型索引
2. hash索引
3. 空间索引
4. 全文索引

### B+Tree索引

B+Tree是一种多路搜索的数据结构类型。它就像一棵树一样，有根节点、叶子结点、枝干等元素。一般在提交到索引的时候，都会提及到二叉树、平衡二叉树、B Tree这几种数据结构，至于为什么会提及呢？主要是B+Tree是根据这几种数据结构演变过来的，因为前面的数据结构存在这种种不足。
> 这里简单提及一下几种数据结构，后面单独出一篇文章来总结这几种数据结构。

#### 索引分类

从 B+Tree数据结构分类，InnoDB中的索引类型分为聚集索引和非聚集索引。聚集索引包含了主键索引，而非聚集索引包含了唯一索引、联合索引、前缀索引、复合索引、普通索引。

### hash索引

hah索引是一种等值类型的数据类型。通过将键值进行hash计算，检索时通过过相同的hash方式进行等值查找的一种存储策略方式。

这种索引类型在等值上检索快(不需要像B+tree进行逐级查找，只需要进行一次的hash计算，就等定位到数据，检索快。)，但是也存在诸多不足之处。例如：
1. 不能进行范围检索。
2. 不能进行大小比较。
3. 不能进行排序检索。

使用该索引也不需要手动去定义，InnoDB存储引擎会根据表的使用情况，自动生成hash索引，不能通过人为的干预生成hash索引。

## 定义索引

### 主键索引

#### 定义
由一个或者多个字段组成的索引列，该索引列是唯一的、自增的、不能为null的。

#### 语法
```mysql
alter table table_name add primary key(column_name)
```

### 唯一索引
    
#### 定义
表中的当前列的值不能重复，但可以为null。

#### 语法
```mysql
alter table table_name add unique(column_name)
```

### 前缀索引

#### 定义
为值的前几个字符创建索引的一种策略。

#### 语法
```mysql
alter table add key(column_name(inde_length))
```
> 该类索引适用于text，blob，varchar等字符类型，但是建议减少该索引类型的使用。

#### 优缺点

1. 便于快速检索数据。
2. 不能使用在order by情况中。
3. 不能使用在group by的情况中。
4. 不能使用在覆盖索引的情况中。
5. 创建的索引长度，最好是根据column_name对应的长度来确定。

### 普通索引

#### 语法
```mysql
alter table table_name add index index_name(column_name)
```

### 联合索引

#### 定义
是表中两个或者两个以上的索引组成的一个新索引。

#### 语法
```mysql
create index index_name on table_name(index_name_1,index_name_2)
```

#### 优缺点
1. 减少数据检索范围。
2. 必须遵循前缀索引原则，够则索引会生效。

### 覆盖索引

#### 定义
一个索引包含(覆盖)所有查询字段的值。

#### 优点
1. 减少回表查询查询额外的字段值。
为什么覆盖索引会检索快呢？
1. 索引检索的数据量始终是小于数据表的数据量。
2. 索引是按照顺序检索的，避免了直接检索表的随机IO读取。
3. 减少系统层面的调用，部分存储引擎读取数据还需要调用系统层面。
4. 在InnoDB的聚集索引中，可以减少二次索引的开销。

## 查看索引

### show语法
```mysql
mysql root@127.0.0.1:demo> show index from `user`\G;
2 rows in set
Time: 0.003s
***************************[ 1. row ]***************************
Table         | user
Non_unique    | 0
Key_name      | PRIMARY
Seq_in_index  | 1
Column_name   | id
Collation     | A
Cardinality   | 7
Sub_part      | <null>
Packed        | <null>
Null          |
Index_type    | BTREE
Comment       |
Index_comment |
***************************[ 2. row ]***************************
Table         | user
Non_unique    | 0
Key_name      | idx_mobiel
Seq_in_index  | 1
Column_name   | mobile
Collation     | A
Cardinality   | 7
Sub_part      | <null>
Packed        | <null>
Null          | YES
Index_type    | BTREE
Comment       |
Index_comment |
```
### explain语法
explain语句可以分析出SQL语句是否使用了索引、检索的类型等情况。
```mysql
mysql root@127.0.0.1:demo> explain select * from `user` where id = 1\G;
1 row in set
Time: 0.003s
***************************[ 1. row ]***************************
id            | 1
select_type   | SIMPLE
table         | user
partitions    | <null>
type          | const
possible_keys | PRIMARY
key           | PRIMARY
key_len       | 4
ref           | const
rows          | 1
filtered      | 100.0
Extra         | <null>
```

## 注意事项

### 创建索引
1. 选择性低的字段不要创建字段。
2. 很少查询的列不要创建索引。
3. 大数据类型的字段不要创建索引。
4. 尽量避免列不要使用null，尽可能的设置为not null。尽可能使用空值来代替这种情况。

### 使用索引

1. 通过索引扫描的行记录数数超过全表的30%，优化器不会走索引，而且会变成全表扫描。
2. 联合索引中，第一个查询条件不是最左索引列不会走索引。
3. 模糊查询条件列最左以"%"开始的。
4. 两个单列索引，一个用于检索，一个用于排序。这种情况是只能使用一个索引，因为SQL查询语句中最多只能使用一个索引，推荐使用联合索引来替代。
5. 查询列上面使用了聚合函数，也不会走索引。

> 专注于PHP、MySQL、Linux和前端开发，感兴趣的感谢点个关注哟！！！文章整理在[GitHub](https://github.com/bruceqiq/code_study),主要包含的技术有PHP、Redis、MySQL、JavaScript、HTML&CSS、Linux、Java、Golang、Linux和工具资源等相关理论知识、面试题和实战内容。

